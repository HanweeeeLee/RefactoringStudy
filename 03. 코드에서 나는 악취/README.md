# 03. 코드에서 나는 악취
> 리펙터링을 언제 시작하고 언제 그만할까  
  
## 3.1 기이한 이름(Mysterious Name)
 - 코드는 단순하고 명료하게 작성해야하며, 코드를 명로하게 표현하는 데 가장 중요한 요소중 하나는 '이름'이다. 
 - 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있어야한다. 
 - 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어있을 확률이 크다. 그래서 혼란스러운 이름을 정리하면 코드가 간결해지는 경우가 많다.
 - ex) 함수 선언 바꾸기, 변수 이름 바꾸기, 필드이름 바꾸기

## 3.2 중복코드(Duplicated Code)
 - 똑같은 코드가 구조 여러곳에서 반복된다면 통합하자
 - 예를들어 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우
  1. **함수 추출하기**를 써서 양쪽 모두 추출된 메서드를 호출하게 사용한다.
  2. 비슷하지만 완전히 같지 않으면 **문장 슬라이드하기**로 비슷한 부분을 한곳에 모아 함수 추출하기를 시도해보자
  3. 같은 부모로부터 파생된 서브 클래스에 중복이 있다면 **메서드 올리기**를 적용해 부모로 옮기자.

## 3.3 긴 함수(Long Function)
 - 간접 호출(indirection)의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나온다.  
 - 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다. 그러기 위해서는 적극적으로 함수를 쪼개야 한다. 주석을 달만한 부분은 함수로 만들자. 함수의 이름은 동작방식이 아닌 의도(intension)가 드러내도록 짓는다.  
 - 함수를 짧게 만드는 작업의 99%는 **함수 추출하기**가 차지한다. <- 함수 본문에서 추출하는것  
 - 함수가 파라미터와 임시변수가 많아서 보기 힘들어진다면 **임시 변수를 질의 함수로 바꾸기**로 임시 변수의 수를, **매개 변수 객체 만들기**와 **객체 통째로 넘기기**로 매개변수의 수를 줄일 수 있다. 그럼에도 임시 변수와 매개변수가 많다면 **함수를 명령으로 바꾸기**를 고려해보자.
 - 추출할 코드 덩어리를 찾는방법은? 코드에 대한 설명이 주석으로 달려있는 경우를 찾아보자. 이것을 주석이 필요없게끔 함수를 추출해보자
 - 조건문이나 반복문도 추출대상의 실마리를 제공한다. 조건문은 **조건문 분해하기**를 사용하거나 switch는 **함수 추출하기**를 적용해서 각 case의 본문을 함수 호출문 하나로 바꾼다. 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 **조건부 로직을 다형성으로 바꾸기**를 적용한다. 
 - 반복문도 그 안의 코드를 추출해서 독립된 함수로 만든다. 추출한 반복문 코드에 적절한 이름이 없다면 성격이 다른 두 가지 작업이 섞여있을 가능성이 있다. 이럴떈 **반복문 쪼개기**를 사용하자

## 3.4 긴 매개변수 목록(Long Parameter List)
 - 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는 **매개변수를 질의 함수로 바꾸기**를 사용해 제거할 수 있다. 
 - 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 **객체 통째로 넘기기**를 적용해서 원본 데이터 구조를 그대로 전달한다. 
 - 항상 함께 전달되는 매개변수들은 **매개변수 객체 만들기**로 하나로 묶는다. 
 - 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 **플래그 인수 제거하기**로 없애준다.
 - 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할떄는 **여러 함수를 클래스로 묶기**를 이용하여 공통 값들을 클래스의 필드로 정의한다.

## 3.5 전역 데이터(Global Data)
 - 전역 데이터, 클래스 변수, 싱글톤은 문제가 많음.. 어디서든 접근할 수 있으니 버그가 생길 확률이 높고, 어디서 데이터를 바꾸어주었는지 추적하기가 어렵다. 
 - **변수 캡슐화하기**를 이용해 방지해보자.

## 3.6 가변 데이터(Mutable Data)
 - 데이터를 변경했더니 다른곳에서는 다른값을 원하는걸 생각하지 못해 버그가 생길 수 있다. 
 - **변수 캡슐화하기**를 적용해 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
 - 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 **변수 쪼개기**를 이용하여 용도별로 독립 변수에 저장하자.
 - 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다 **문장 슬라이드하기**와 **함수 추출하기**를 이용해서 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리하자
 - API를 만들 때는 **질의 함수와 변경 함수 분리하기**를 활용해서 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다.
 - **세터 제거하기**를 사용하는것도 좋다.
 - 값을 다른 곳에서 설정할 수 있는 가변데이터는 야근의 원흉. **파생 변수를 질의 함수로 바꾸기**를 사용하자
 - **여러 함수 클래스로 묶기**나 **여러함수를 변환 함수로 묶기**를 활용해서 변수를 갱신하는 코드들의 유효범위를 제한하자.
 - 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 일반적으로 **참조를 값으로 바꾸기**를 적용해 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하자

## 3.7 뒤엉킨 변경(Divergent Change)
> 뒤엉킨 변경은 SRP가 지켜지지 않을 때 나타난다. 즉 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다. 데이터 베이스를 예로 들자면..  
 - 데이터 베이스에서 데이터를 가져와서 금융 상품 로직에서 처리해야 하는 일처럼 순차적으로 실행되는 게 자연스러운 맥락이라면, 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다(**단계 쪼개기**)
 - 전체 처리 과정에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면 적절한 모듈을 만들어 함수를 모은다(**함수 옮기기**)
 - 이때 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 **함수 추출하기**부터 수행한다. 
 - 모듈이 클래스라면 **클래스 추출하기**를 사용하자




























