# 03. 코드에서 나는 악취
> 리펙터링을 언제 시작하고 언제 그만할까  
  
## 3.1 기이한 이름(Mysterious Name)
 - 코드는 단순하고 명료하게 작성해야하며, 코드를 명로하게 표현하는 데 가장 중요한 요소중 하나는 '이름'이다. 
 - 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있어야한다. 
 - 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어있을 확률이 크다. 그래서 혼란스러운 이름을 정리하면 코드가 간결해지는 경우가 많다.
 - ex) 함수 선언 바꾸기, 변수 이름 바꾸기, 필드이름 바꾸기

## 3.2 중복코드(Duplicated Code)
 - 똑같은 코드가 구조 여러곳에서 반복된다면 통합하자
 - 예를들어 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우
  1. **함수 추출하기**를 써서 양쪽 모두 추출된 메서드를 호출하게 사용한다.
  2. 비슷하지만 완전히 같지 않으면 **문장 슬라이드하기**로 비슷한 부분을 한곳에 모아 함수 추출하기를 시도해보자
  3. 같은 부모로부터 파생된 서브 클래스에 중복이 있다면 **메서드 올리기**를 적용해 부모로 옮기자.

## 3.3 긴 함수(Long Function)
 - 간접 호출(indirection)의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나온다.  
 - 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다. 그러기 위해서는 적극적으로 함수를 쪼개야 한다. 주석을 달만한 부분은 함수로 만들자. 함수의 이름은 동작방식이 아닌 의도(intension)가 드러내도록 짓는다.  
 - 함수를 짧게 만드는 작업의 99%는 **함수 추출하기**가 차지한다. <- 함수 본문에서 추출하는것  
 - 함수가 파라미터와 임시변수가 많아서 보기 힘들어진다면 **임시 변수를 질의 함수로 바꾸기**로 임시 변수의 수를, **매개 변수 객체 만들기**와 **객체 통째로 넘기기**로 매개변수의 수를 줄일 수 있다. 그럼에도 임시 변수와 매개변수가 많다면 **함수를 명령으로 바꾸기**를 고려해보자.
 - 추출할 코드 덩어리를 찾는방법은? 코드에 대한 설명이 주석으로 달려있는 경우를 찾아보자. 이것을 주석이 필요없게끔 함수를 추출해보자
 - 조건문이나 반복문도 추출대상의 실마리를 제공한다. 조건문은 **조건문 분해하기**를 사용하거나 switch는 **함수 추출하기**를 적용해서 각 case의 본문을 함수 호출문 하나로 바꾼다. 같은 조건을 기준으로 나뉘는 switch문이 여러 개라면 **조건부 로직을 다형성으로 바꾸기**를 적용한다. 
 - 반복문도 그 안의 코드를 추출해서 독립된 함수로 만든다. 추출한 반복문 코드에 적절한 이름이 없다면 성격이 다른 두 가지 작업이 섞여있을 가능성이 있다. 이럴떈 **반복문 쪼개기**를 사용하자

## 3.4 긴 매개변수 목록(Long Parameter List)
 - 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는 **매개변수를 질의 함수로 바꾸기**를 사용해 제거할 수 있다. 
 - 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 **객체 통째로 넘기기**를 적용해서 원본 데이터 구조를 그대로 전달한다. 
 - 항상 함께 전달되는 매개변수들은 **매개변수 객체 만들기**로 하나로 묶는다. 
 - 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 **플래그 인수 제거하기**로 없애준다.
 - 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할떄는 **여러 함수를 클래스로 묶기**를 이용하여 공통 값들을 클래스의 필드로 정의한다.

## 3.5 전역 데이터(Global Data)
 - 전역 데이터, 클래스 변수, 싱글톤은 문제가 많음.. 어디서든 접근할 수 있으니 버그가 생길 확률이 높고, 어디서 데이터를 바꾸어주었는지 추적하기가 어렵다. 
 - **변수 캡슐화하기**를 이용해 방지해보자.

## 3.6 가변 데이터(Mutable Data)
 - 데이터를 변경했더니 다른곳에서는 다른값을 원하는걸 생각하지 못해 버그가 생길 수 있다. 
 - **변수 캡슐화하기**를 적용해 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
 - 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 **변수 쪼개기**를 이용하여 용도별로 독립 변수에 저장하자.
 - 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다 **문장 슬라이드하기**와 **함수 추출하기**를 이용해서 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리하자
 - API를 만들 때는 **질의 함수와 변경 함수 분리하기**를 활용해서 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다.
 - **세터 제거하기**를 사용하는것도 좋다.
 - 값을 다른 곳에서 설정할 수 있는 가변데이터는 야근의 원흉. **파생 변수를 질의 함수로 바꾸기**를 사용하자
 - **여러 함수 클래스로 묶기**나 **여러함수를 변환 함수로 묶기**를 활용해서 변수를 갱신하는 코드들의 유효범위를 제한하자.
 - 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 일반적으로 **참조를 값으로 바꾸기**를 적용해 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하자

## 3.7 뒤엉킨 변경(Divergent Change)
> 뒤엉킨 변경은 SRP가 지켜지지 않을 때 나타난다. 즉 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다. 데이터 베이스를 예로 들자면..  
 - 데이터 베이스에서 데이터를 가져와서 금융 상품 로직에서 처리해야 하는 일처럼 순차적으로 실행되는 게 자연스러운 맥락이라면, 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다(**단계 쪼개기**)
 - 전체 처리 과정에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면 적절한 모듈을 만들어 함수를 모은다(**함수 옮기기**)
 - 이때 여러 맥락의 일에 관여하는 함수가 있다면 옮기기 전에 **함수 추출하기**부터 수행한다. 
 - 모듈이 클래스라면 **클래스 추출하기**를 사용하자

## 3.8 산탄총 수술(shotgun Surgery)
> 산탄총 수술은 뒤엉킨 변경과 비슷하면서 정 반대다. 이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.  

|  | 뒤엉킨 변경 | 산탄총 수술 |  
|:---:|:---:|:---:|
| 원인 | 맥락을 잘 구분하지 못함 ||
| 해법(원리) | 맥락을 명확히 구분 ||
| 발생 과정(현상) | 한 코드에 섞여 들어감 | 여러 코드에 흩뿌려짐 |
| 해법(실제 행동) | 맥락별로 분리 | 맥락별로 모음 |

  - 함께 변경되는 대상들을 **함수 옮기기**와 **필드 옮기기**로 모두 한 모듈에 묶어놓으면 좋다
  - 비슷한 데이터를 다루는 함수가 많다면 **여러 함수를 클래스로 묶기**를 적용한다. 
  - 데이터 구조를 변환하거나 보강하는 함수들에게는 **여러 함수를 변환 함수로 묶기**를 적용한다.
  - 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 로직으로 전달할 수 있다면 **단위 쪼개기**를 적용하자
  - 어설프게 분리된 로직을 **함수 인라인하기**나 **클래스 인라인하기**같은 인라인 리팩터링으로 합치는것도 좋다. 

## 3.9 기능 편애(Feature Envy)
> 기능 편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다는 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을떄 풍기는 냄새다.  

 - 외부 객체의 게터 메서드 많이 호출한다면? 이 함수가 데이터와 가까이 있고 싶어한다는 의중이 드러나므로 소원데로 데이터 근처로 옮겨주면 된다(**함수 옮기기**)
 - 함수의 일부에서만 기능을 편애한다면? 그 부분만 독립함수로 빼낸다음(**함수 추출하기**) 원하는 모듈로 보내준다(**함수 옮기기**) 
 - 함수가 사용하는 모듈이 다양하다면? 가장 많은 데이터를 포함한 모듈로 옮긴다. **함수 추출하기**로 함수를 여러 조각으로 나눈 후 적절한 모듈로 옮기면 더 좋다.

## 3.10 데이터 뭉치(Data Clumps)
> 데이터 항목들은 서로 어울리는걸 좋아한다. 이렇게 몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 마땅하다

 - 필드 형태의 데이터 뭉치를 찾아서 **클래스 추출하기**로 하나의 객체로 묶는다.
 - **매개변수 객체 만들기**나 **객체를 통쨰로 넘기기**를 적용해서 매개변수 수를 줄여본다. 

## 3.11 기본형 집착(Primitive Obsession)
> 전화번호나 화퍠, 좌표등을 기본형으로 쓰지 말자

 - **기본형을 객체로 바꾸기**를 적용하면 기본형만이 거주하는 구석기 동굴을 온돌식 코드로 바꿀 수 있다. 
 - 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입코드로 쓰였다면 **타입 코드를 서브 클래스로 바꾸기**와 **조건부 로직을 다형성으로 바꾸기**를 적용하자
 - 함께 몰려다니는 기본형 그룹도 데이터 뭉치다. 따라서 **클래스 추출하기**와 **매개변수 객체 만들기**를 이용하여 반드시 문명사회로 이끌어줘야 한다.

## 3.12 반복되는 switch문(Repeated Switches)
> 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문이다. 이럴때 다형성은 반복된 switch문을 세련되게 바꿔줄 수 있다.

## 3.13 반복문(Loops)
> 반복문은 프로그래밍 언어가 등장할떄부터 있었지만, 이제는 고물이다. 
 - 지금은 일급 함수(first-class function)를 지원하는 언어가 많아졌기 때문에 **반복문을 파이프라인으로 바꾸기**를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다. 필터나 맵 같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

## 3.14 성의 없는 요소(Lazy Element)
> 메서드가 하나밖에 없는 클래스나 이런것들은.. 보내드리자..

 - 이 제거 작업은 **함수 인라인하기**나 **클래스 인라인하기**로 처리한다. 상속을 사용했다면 **계층 합치기**를 적용한다.

## 3.15 추측성 일반화(Speculative Generality)
> ???: 나중에 필요할꺼야

 - 하는 일이 거의 없는 추상 클래스는 **계층 합치기**로 제거한다.
 - 쓸대 없이 위임하는 코드는 **함수 인라인하기**나 **클래스 인라인하기**로 삭제한다.
 - 본문에서 사용되지 않는 매개변수는 **함수 선언 바꾸기**로 없앤다.
 - 테스트코드에서 사용하고 있어도 테스트케이스부터 삭제하고 **죽은 코드 제거하기**로 날려버리자.


## 3.16 임시 필드(Temporary Field)
> 특정 상황에서만 값이 설정되는 필드르 가진 클래스도 있다. <- 이러면 안됨

 - 이렇게 덩그러니 떨어져 있는 필드들을 발견하면 **클래스 추출하기**로 제 살곳을 찾아주자. 그런다음 **함수 옮기기**로 임시 필드들과 관련된 코드를 모조리 새 클래스에 몰아넣는다. 
 - 임시 필드들이 유효한지 확인한 후 동작하는 조건부 로직이 있다면 **특이 케이스 추가하기**로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어 제거할 수 있다.

## 3.17 메시지 체인(Message Chain)
> 메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 엊은 객체에 또 다른 객체를 요청하는 방식

 - **위임 숨기기**로 해결하자
 - **함수 추출하기**로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 **함수 옮기기**로 체인을 숨길 수 있는자 살펴보자.

ex)
```JS
managerName = aPerson.department.manager.name; // 메시지 체인

/* 위임 숨기기 */
managerName = aPerson.department.managerName // 관리자 객체(manager)의 존재를 숨김
managerName = aPerson.manager.name // 부서 객체(department))의 존재를 숨김
managerName = aPerson.managerName // 부서 객체와 관리자 객체 모두의 존재를 숨김

/* 이 체인의 최종 결과는 name이 반환하는 부서정의 이름이다. 이 객체가 다음처럼 쓰인다고 해보자 */
managerName = aPerson.department.manager.name
report = '${managerName}께 ${aPerson.name}님의 작업 로그 ...'
console.log(report)

/* 여기서 보고서 생성 로직을 함수로 추출한 다음 적당한 모듈로 옮기면 체인의 존재가 감춰진다. */
console.log(reportAuthGenerator.report(aPerson))

/* 마지막으로 체인의 중간인 부서 정보를 얻어 사용하는 다수의 클라이언트가 부서장 이름도 함께 사용한다면 부서 클래스에 managerName() 메서드를 추가하여 체인을 단축할 수 있다.*/
```

## 3.18 중개자(Middle Man)
> 캡슐화하는 과정에서는 위임(delegate)이 자주 활용된다.

 - 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면? **중개자 제거하기**를 사용해 실제로 일을 하는 객체와 직접 소통하게 하자. 
 - 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자.(**함수 인라인하기**)

## 3.19 내부자 거래(Insider Trading)
> 소프트웨어 개발자는 모듈 사이에 벽을 두껍게 세워두기를 좋아하며 모듈사이의 데이터 거래가 많으면 결합도가 높아진다고 투덜된다. 일이 되게하려면 어쩔 수 없지만 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.  

 - 은밀하게 데이터를 주고받는 모듈이 있다면 **함수 옮기기**와 **필드 옮기기**기법으로 떼어놓아서 사적으로 처리하는 부분을 줄이자.
 - 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제3의 모듈을 새로 만들거나 **위임 숨기기**를 이용하여 다른 모듈이 중간자 역할을 하게 만든다.
 - 상속 구조에서는 부모자식간의 결합이 생길떄가 있다. 부모 품을 떠나야 할때가 온다면 **서브클래스를 위임으로 바꾸기**나 **슈퍼클래스를 위임으로 바꾸기**를 활용하자.

## 3.20 거대한 클래스(Large Class)
> 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.

 - 이럴 때는 **클래스 추출하기**로 필드들 일부를 따로 묶는다. 
 - 이렇게 분리할 컴포넌트를 원래 클래스와 상속관계로 만드는게 좋다면 **슈퍼클래스 추출하기**나 **타입 코드를 서브클래스로 바꾸기**를 적용하자.
 - 그룹을 나는 후 **클래스 추출하기**, **슈퍼클래스 추출하기**, **타입코드를 서브클래스로 바꾸기**등을 활용해서 여러 클래스로 분리하자.

## 3.21 서로 다른 인터페이스의 대안 클래스들(Alternative Classes with Differenct Interfaces)
> 클래스를 사용할 때의 큰 장점은 언제든 다른 클래스로 교체할 수 있다는 것이다.  

 - 단 교체하려면 인터페이스가 같아야 한다. 따라서 **함수 선언 바꾸기**로 메서드 시그니처를 일치시킨다.
 - 부족하다면 **함수 옮기기**를 이용해 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 넣는다. 
 - 중복코드가 생기면 **슈퍼클래스 추출하기**를 적용해볼지 고민해본다. 

## 3.22 데이터 클래스(Data Class)
> 데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다. 

 - 데이터 저장용도로만 쓰이다보니 다른 클래스가 너무 깊이 관여할 떄가 있다. 만약 public이 있으면 **레코드 캡슐화하기**로 숨기자.
 - 변경하면 안되는 필드는 **세터 제거하기**를 사용하자.
 - 다른 클래스에서 데이터 클래스의 게터나 세터를 사용하는 메서드를 찾아서 **함수 옮기기**로 메서드를 데이터 클래스로 옮길 수 있나 찾아보자.
 - 메서드를 통째로 옮기기 어렵다면 **함수 추출하기**를 이용해서 옮길 수 있는 부분만 메서드로 뽑아낸다.

## 3.23 상속 포기(Refused Bequest)
> 부모의 모든 기능을 받지 않고 일부만 받고싶다면?

 - 계층구조를 잘못 설계했다면 같은 계층에 서브클래스를 만들고 **메서드 내리기**와 **필드 내리기**를 활용해 물려받지 않을 부모 코드를 모조리 새로 만든 서브클래스로 넘긴다. 그러면 부모에는 공통된 부분만 남는다. 
 - 상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을떄 심하게 난다. 이럴 때는 **서브클래스를 위임으로 바꾸기**나 **슈퍼클래스를 위임으로 바꾸기**를 활용해보자.

## 3.24 주석(Comments)
> 주석 제대로 달자. 

 - 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 **함수 추출하기**를 적용해본다.
 - 이미 추출되있다면 **함수 선언 바꾸기**로 함수의 이름을 바꿔본다.
 - 시스템이 동작하기 위한 선행 조건을 명시하고 싶다면 **어서션 추가하기**를 사용해보자.
### 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다. 































