# 02. 리팩터링 원칙
## 2.1 리팩터링 정의

> 리팩터링  
> [명사]소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법.  
> [동사]소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.  
> 누군가 “리팩터링하다가 코드가 깨져서 며칠이나 고생했다”라고 한다면, 십중팔구 리팩터링한 것이 아니다.

## 2.2 두개의 모자
 - 기능 추가와 리팩터링을 명확히 구분해서 작업하는 방법이다.
 - 기능추가 모자를 쓴 상태이면 기존 코드는 절대 건드리지 않고 새 기능을 추가만 한다.
 - 리팩터링 모자를 쓴 상태이면 오로지 코드 재구성에만 전념한다. 인터페이스를 변경해야 할때만 기존 테스트를 수정한다.

## 2.3 리팩터링하는 이유
 - 소프트웨어 설계가 좋아진다. -> 규칙적인 리팩터링을 통해 설계가 부패되는 것을 막을 수 있다.
 - 소프트웨어를 이해하기 쉬워진다. -> 의도를 더 명확하게 전달하도록 리팩터링함으로써 나 자신 또는 다른 팀원들이 코드를 쉽고 빠르게 이해할 수 있다.
 - 버그를 쉽게 찾을수 있다.
 - 프로그래밍 속도를 높일 수 있다

## 2.4 언제 리팩터링해야 할까?
> 돈 로버츠가 제시한 3의 법칙

 - 1. 처음에는 그냥 진행한다.
 - 2. 비슷한 일을 두번째로 하게되면(중복이 생겼다는 사실에 당황스럽지만) 일단 계속 진행한다.
 - 3. 비슷한 일을 세번째 하게 되면 리팩터링 한다.

> 준비를 위한 리팩터링

 - 기능을 쉽게 추가하게 만들기
 - 현재 구조를 살펴보고 구조를 다듬어서 새로운 기능을 적용하기 좋게 만들어주자.
 - 버그를 잡을때도 좋다. 버그를 한 군데로 모아서 리팩터링하는 것이다.

> 이해를 위한 리팩터링

 - 코드를 이해하기 쉽게 만들기
 - 수정을 하려면 이해를 해야한다. 이해를 한 다음 간단하게 변수, 함수의 이름을 바꾸는 것 만으로도 전체 설계가 눈에 들어오기 시작한다.
 - 이해한 것을 코드 속에 녹여내야 한다. 그래야 다음에 코드를 들여다 볼때 또다시 이해를 해야하는 과정을 뛰어넘을 수 있다.

> 쓰레기 줍기 리팩터링

 - 쓰레기가 나뒹굴게 방치해서 나중에 일을 방해하게 내버려둘 수는 없다.
 - 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모를 남긴 다음, 하던 일을 끝내고 나서 처리한다

> 계획된 리팩터링과 수시로 하는 리팩터링

 - 앞선 세가지의 리팩터링 방식은 기회가 될때에 하는 것이다.
 - (때로는 필요할 수 있지만) 리팩터링이란 계획적으로 하는게 아니다.
 - 계획된 리팩터링을 하게되는 일은 최소한으로 줄이고, 대부분의 리팩터링 작업은 드러나지않게 기회가 될때마다 해야 한다.

> 오래 걸리는 리팩터링

 - 골치 아픈 의존성 정리를 하는 상황이더라도 팀전체가 리팩터링에 매달리는 것에는 회의적이다.
 - 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적이다.

> 코드 리뷰에 리팩터링 활용하기

 - 작성자와 함께 앉아 코드를 훑어가면서 리팩터링 하자(pair programming)

> 관리자에게는 뭐라고 말해야 할까?

 - 가치 있는 기능을 만들어내지 못하는 작업이라고 오해하여 리팩터링이 금지가 된 조직도 있다. 
 - 리팩터링의 필요성을 아는 관리자라면 리팩터링을 권장할 것이며, 팀원의 리팩터링 역량이 충분한지 수시로 살펴볼 것이다.
 - 필요성을 모르는 관리자라면 말하지 말자. 내가 필요성을 알고, 그 덕분에 더 빠르게 개발할 수 있다는 것을 알면 책임있게, 프로답게, 리팩터링을 하는 것이다.

> 리팩터링 하지 말아야 할때

 - 굳이 수정할 필요 없다면 하지 말자. 외부 API 또는 그와 유사하게 호출하여 쓰는 코드라면 그냥 두자. 충분히 내부동작을 이해해야 할 시점에 리팩터링을 하면 된다.
 - 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때에도 리팩터링하지 않는다.

## 2.5 리팩터링 시 고려할 문제
리팩터링이 많은 팀에서 적극적으로 도입해야 할 중요한 기법이라고 저자는 권고한다.  
하지만 엄연히 딸려오는 문제도 존재하기에 이런 문제가 언제 발생하고, 어떻게 대처해야 할지를 반드시 알아야 한다.

> 새 기능 개발 속도 저하

 - 당장 보아서는 속도가 느려지는 것 같지만, 리팩터링의 궁극적인 목적은 개발 속도를 높이는데 있다.
 - 리팩터링은 도덕적, 미학적 이유로 하는 것이 아니다. 오로지 경제적인 이유로 하는 것이다.

> 코드 소유권

 - 고객에게 API로 제공되거나, 함수를 호출하는 코드의 소유자가 다른 팀인 경우 함수 이름을 바꾸는 것조차 간단하지 않을 때가 있다.
 - 그래서 저자는 코드 소유권을 작은 단위로 나눠 엄격히 관리하는 데 반대한다. 
 - 좀 더 자유롭고 넓은 코드 수정권한을 주어서 관리의 책임은 나누되 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 해야 한다.

> 브랜치

 - 기능 단위 브랜치로 개발시 master브랜치로 머지와 통합이 복잡해지는 문제를 줄이기 위해서 지속적 통합(Continuous Integration)을 해야한다.
 - 모든 팀원이 하루에 최소 한번은 마스터와 통합한다.

> 테스팅

 - 리팩터링의 대표적 특징은 겉보기 동작이 똑같이 유지된다는 것이다. 절차를 지켜 제대로 리팩터링하면 동작이 깨지지 않아야 한다.
 - 만약 실수가 생기더라도 재빨리 해결하면 문제가 되지 않는다.
 - 절차를 지켜 리팩터링 하면 단계별 변경이 작다. 리팩터링은 변경폭이 작아서 오류를 빨리 발견할수 있다. 원인을 찾지 못하더라도 버전 관리 시스템을 이용하여 되돌리면 된다.

> 레거시 코드

 - 물려받은 레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많다.
 - 대규모 레거시 시스템을 테스트 코드 없이 리팩터링하기는 어렵다.
 - 쉽게 해결할 방법은 없다. 단순 노동에 가까울수 있지만 테스트를 보강해야 한다.

> 데이터베이스

 - 데이터베이스가 리팩터링하기 어려운 영역이지만, 요새는 그렇지만도 않다.
 - 예를 들어 필드의 이름을 변경하는 경우, 예전 필드를 사용하는 데이터 모두 새 필드를 사용하도록 변환해야 한다.
 - 이 변환을 수행하는 코드를 간단히 작성 후, 선언된 데이터 구조나 접근 루틴을 변경하는 코드와 함께 버전 관리 시스템에 저장한다.
 - 데이터베이스를 다른 버전으로 이전할 때마다 현재 버전에서 원하는 버전 사이에 있는 모든 마이그레이션 스크립트를 실행한다.
 - 다른 리팩터링과 마찬가지로 가능한 작은 여러단계로 나누어서 한다. 프로덕션 환경에서 문제가 생겼을때 되돌리기 쉽기 때문이다.

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)
가령 함수를 정의하다보면 보다 범용적으로 사용할수 있겠다라는 생각이 들때가 있다.  
다양한 예상 시나리오에 대응하기 위해 함수에 매개변수들을 추가하는 것을 유연성 매커니즘이라고 말한다.  
하지만 추가 하다보면 당장의 쓰임에 비해 복잡해지거나, 혹은 요구사항이 달라지거나, 내가 설계한 매커니즘 자체에 결함이 있을수도 있다.  
이 모든 상황을 고려하다 보면 유연성 매커니즘이 오히려 변화에 대응하는 능력을 떨어뜨릴 때가 대부분이다.

### YAGNI (You Aren’t Going to Need It)
 - 앞으로 어느 부분에 유연성이 필요하고 어떻게 해야 그 변화에 가장 잘 대응할 수 있을지 추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 단, 이 요구를 멋지게 해결하도록 설계한다.
 - 간결한 설계, 점진적 설계라고도 부른다.
 - 나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 것이 낫다.
 - 아키텍처를 전혀 고려하지 말라는 의미는 아니고, 리팩터링이 뒷받침 되어야만이 효과를 볼수 있다.

## 2.7 리팩터링과 소프트웨어 개발 프로세스
 - 자가 테스트 코드를 통해 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할수 있어야 한다.
 - 지속적 통합을 통하여 팀원 각자가 수행한 리팩터링 결과를 빠르게 공유하여 삭제될 인터페이스를 통해 새로운 기능을 추가하는 일을 방지할수 있고, 다른팀원의 작업에 문제를 일으키면 바로 알수도 있다.
 - 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 기법은 서로 강력한 상승효과를 발휘한다.
 - 추측에 근거한 유연성 메커니즘을 갖춘 시스템보다는 단순한 시스템이 변경하기가 훨씬 쉽고, 위 세가지 실천법과 YAGNI 설계방식을 따르면 요구사항 변화에 재빠르게 대응하고 안정적인 선순환 구조를 코드베이스에 심을수 있다.

## 2.8 리팩터링과 성능

리팩터링하면 성능이 느려질까봐 걱정하는 사람이 많다.  
실제로 저자는 이해하기 쉽게 만들기 위해 속도가 느려지는 방향으로 수정하는 경우가 많다고 한다.  
하드 리얼타임(hard real-time) 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다.  

> 소프트웨어를 작성하는 방법 세 가지

 - 시간예산 분배(time budgeting) : 하드 리얼타임 시스템에서 많이 사용. 자원을 최적으로 할당한다.
 - 끊임없이 관심 기울이기 : 성능 개선에만 신경쓰면 코드가 점점더 알아보기 어렵게 되고, 컴파일러, 런타임, 하드웨어 동작을 충분히 이해하지 못한 코드가 된다.
 - 일단은 코드를 다루기 쉽게 만드는데 집중하자. 성능 최적화 단계가 되면 프로그램을 튜닝한다.
 
이 중 세번째 방식의 튜닝방법은  

 - 프로파일러로 프로그램을 분석하여 시간과 공간을 잡아먹는 지점을 알아낸다.
 - 알아낸, 개선할 수 있는 작은 부분들을 개선한다. 적은 노력으로 큰 효과를 얻을 수 있다.
 - 리팩터링할 때처럼 작은 단계로 나누어 컴파일과 테스트를 거치고 프로파일러를 다시 실행해본 후, 성능이 개선되지 않았다면 수정 내용을 되돌린다.

이런 식으로 만족하는 성능에 도달할 때까지 최적화 대상을 찾아서 제거하는 일을 반복한다. 이와 같이 진행하면  

 - 리팩터링이 잘 되어있다면 기능 추가가 빨리 끝나서 성능에 집중할 시간을 벌수 있다.
 - 프로파일러가 지적해주는 코드의 범위가 더 좁아지고, 튜닝하기 쉬워지므로 성능을 더 세밀하게 분석 할 수 있고 튜닝하기 쉬워진다.

단기적으로 보면 리팩터링 단계에선 성능이 느려질 수 있지만, 최적화 단계에서 코드를 튜닝하기 쉬워지기 때문에 더 빠른 소프트웨어를 얻게 된다.

## 2.9 리팩터링의 유래

리팩터링이라는 용어의 정확한 유래를 찾을 수는 없었다.  
여러 경험을 통해 저자는 리팩토링이 정말 중요한 기법이라는 걸 깨달았지만 프로그래머가 읽을 만한 책이 하나도 없었기에 저자가 책을 작성하게 되었다.  
다행히 업계에서 리팩터링이라는 개념을 잘 받아 들였고 현재 리팩터링은 주류 개발 기법으로 자리 잡았다.

## 2.10 리팩터링 자동화

자바를 기준을 인텔리제이 나 이클립스 에서 메서드 이름을 바꾸는 작업을 메뉴에서 원하는 항목을 클릭하는 것만으로 처리할수 있다.  
실제 리팩터링은 내가 아니라 개발 도구가 처리해주며, 따로 테스트할 필요가 없을 정도로 안정적이다.
